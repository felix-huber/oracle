import stringWidth from "string-width";
import stripAnsi from "strip-ansi";
import { hyperlinkSupported, osc8 } from "./hyperlink.js";
import { parse } from "./parser.js";
import { createStyler, themes } from "./theme.js";
import { visibleWidth, wrapText, wrapWithPrefix } from "./wrap.js";
function dedent(markdown) {
    const lines = markdown.split("\n");
    const indents = lines
        .filter((l) => l.trim() !== "")
        .map((l) => l.match(/^[ \t]*/)?.[0].length ?? 0);
    if (indents.length === 0)
        return markdown;
    const minIndent = Math.min(...indents);
    if (minIndent === 0)
        return markdown;
    return lines.map((l) => l.slice(Math.min(minIndent, l.length))).join("\n");
}
function resolveOptions(userOptions = {}) {
    const wrap = userOptions.wrap !== undefined ? userOptions.wrap : true;
    const baseWidth = userOptions.width ?? (wrap ? process.stdout.columns || 80 : undefined);
    const color = userOptions.color !== undefined ? userOptions.color : process.stdout.isTTY;
    // OSC hyperlinks require color support; if color is off, force hyperlinks off too
    const hyperlinks = userOptions.hyperlinks !== undefined
        ? userOptions.hyperlinks
        : color && hyperlinkSupported();
    const effectiveHyperlinks = color ? hyperlinks : false;
    const baseTheme = themes.default ?? {};
    const userTheme = userOptions.theme && typeof userOptions.theme === "object"
        ? userOptions.theme
        : themes[userOptions.theme || "default"] || baseTheme;
    const mergedTheme = {
        ...baseTheme,
        ...(userTheme || {}),
        inlineCode: userTheme?.inlineCode ||
            userTheme?.code ||
            baseTheme.inlineCode ||
            baseTheme.code ||
            {},
        blockCode: userTheme?.blockCode ||
            userTheme?.code ||
            baseTheme.blockCode ||
            baseTheme.code ||
            {},
    };
    const highlighter = userOptions.highlighter;
    const listIndent = userOptions.listIndent ?? 2;
    const quotePrefix = userOptions.quotePrefix ?? "│ ";
    const tableBorder = userOptions.tableBorder || "unicode";
    const tablePadding = userOptions.tablePadding ?? 1;
    const tableDense = userOptions.tableDense ?? false;
    const tableTruncate = userOptions.tableTruncate ?? true;
    const tableEllipsis = userOptions.tableEllipsis ?? "…";
    const codeBox = userOptions.codeBox ?? true;
    const codeGutter = userOptions.codeGutter ?? false;
    const codeWrap = userOptions.codeWrap ?? true;
    const resolved = {
        wrap,
        color,
        hyperlinks: effectiveHyperlinks,
        theme: mergedTheme,
        highlighter,
        listIndent,
        quotePrefix,
        tableBorder,
        tablePadding,
        tableDense,
        tableTruncate,
        tableEllipsis,
        codeBox,
        codeGutter,
        codeWrap,
    };
    if (baseWidth !== undefined)
        resolved.width = baseWidth;
    return resolved;
}
/**
 * Normalize parsed nodes to avoid misclassifying reference-style metadata as code.
 * Some sources emit footnote-like link definitions where the title is placed
 * on the following indented lines (often copied with tabs). When GFM parsing
 * misses the closing quote, those continuations become indented code blocks.
 * To keep output readable, merge such continuations back into the definition
 * paragraph and render as regular text.
 */
function extractText(node) {
    if (typeof node.value === "string")
        return node.value;
    if (Array.isArray(node.children)) {
        return node.children.map((child) => extractText(child)).join("");
    }
    return "";
}
function getParagraphText(node) {
    return extractText(node);
}
function normalizeNodes(tree) {
    const normalized = [];
    for (let i = 0; i < tree.children.length; i += 1) {
        const node = tree.children[i];
        if (node?.type === "paragraph" && node.children.length >= 1) {
            const text = getParagraphText(node);
            const defMatch = text.match(/^\[(\d+|\w+)]:\s+\S.*"\s*$/);
            const next = tree.children[i + 1];
            if (defMatch && next?.type === "code" && !next.lang) {
                const continuation = next.value
                    .replace(/^[ \t>]+/gm, " ")
                    .replace(/\s+/g, " ")
                    .trim();
                const merged = `${text.replace(/\s+"$/, '"')} ${continuation ? continuation.replace(/^"+|"+$/g, "").trim() : ""}`.trim();
                normalized.push({
                    type: "paragraph",
                    children: [{ type: "text", value: merged }],
                    position: node.position,
                });
                i += 1; // skip the consumed code block
                continue;
            }
        }
        // As a fallback, rewrite indented code blocks that look like lone definitions.
        if (node?.type === "code" && !node.lang) {
            const stripped = node.value.replace(/^[ \t>]+/gm, "").trim();
            if (/^\[(\d+|\w+)]:\s+\S+/.test(stripped)) {
                normalized.push({
                    type: "paragraph",
                    children: [{ type: "text", value: stripped }],
                    position: node.position,
                });
                continue;
            }
        }
        if (node)
            normalized.push(node);
    }
    const mergedCodes = mergeAdjacentCodeBlocks(normalized);
    const taggedDiffs = mergedCodes.map((child) => tagDiffBlock(child));
    return { ...tree, children: taggedDiffs };
}
function flattenCodeList(list) {
    if (!list.children.length ||
        !list.children.every((item) => item.children.length === 1 &&
            item.children[0]?.type === "code" &&
            item.children[0].value !== undefined))
        return null;
    const codes = list.children.map((item) => item.children[0]);
    const sameLang = codes.every((c) => c.lang === codes[0]?.lang);
    const lang = sameLang ? (codes[0]?.lang ?? undefined) : undefined;
    return {
        type: "code",
        lang: lang ?? undefined,
        value: codes.map((c) => c.value).join("\n"),
        position: list.position,
    };
}
function mergeAdjacentCodeBlocks(nodes) {
    const out = [];
    let pending = null;
    const flush = () => {
        if (pending) {
            out.push(pending);
            pending = null;
        }
    };
    for (const node of nodes) {
        if (node?.type === "code") {
            if (pending &&
                (pending.lang === node.lang || (!pending.lang && !node.lang))) {
                const nextValue = `${pending.value}\n${node.value}`;
                pending = {
                    type: "code",
                    lang: pending.lang,
                    meta: pending.meta,
                    value: nextValue,
                    position: pending.position,
                };
            }
            else {
                flush();
                pending = node;
            }
            continue;
        }
        if (node?.type === "list") {
            const flattened = flattenCodeList(node);
            if (flattened) {
                if (pending &&
                    (pending.lang === flattened.lang ||
                        (!pending.lang && !flattened.lang))) {
                    const nextValue = `${pending.value}\n${flattened.value}`;
                    pending = {
                        type: "code",
                        lang: pending.lang,
                        meta: pending.meta,
                        value: nextValue,
                        position: pending.position,
                    };
                }
                else {
                    flush();
                    pending = flattened;
                }
                continue;
            }
        }
        flush();
        out.push(node);
    }
    flush();
    return out;
}
function looksLikeDiff(text) {
    const lines = text.split("\n").map((l) => l.trim());
    if (lines.some((l) => l.startsWith("diff --git") ||
        l.startsWith("--- a/") ||
        l.startsWith("+++ b/") ||
        l.startsWith("@@ ")))
        return true;
    const nonEmpty = lines.filter((l) => l !== "");
    if (nonEmpty.length < 3)
        return false;
    const markers = nonEmpty.filter((l) => /^[+\-@]/.test(l)).length;
    return markers >= Math.max(3, Math.ceil(nonEmpty.length * 0.6));
}
function tagDiffBlock(node) {
    if (node?.type === "code" && !node.lang && looksLikeDiff(node.value)) {
        return { ...node, lang: "diff" };
    }
    return node;
}
const HR_WIDTH = 40;
const MAX_COL = 40;
const TABLE_BOX = {
    unicode: {
        topLeft: "┌",
        topRight: "┐",
        bottomLeft: "└",
        bottomRight: "┘",
        hSep: "─",
        vSep: "│",
        tSep: "┬",
        mSep: "┼",
        bSep: "┴",
        mLeft: "├",
        mRight: "┤",
    },
    ascii: {
        topLeft: "+",
        topRight: "+",
        bottomLeft: "+",
        bottomRight: "+",
        hSep: "-",
        vSep: "|",
        tSep: "+",
        mSep: "+",
        bSep: "+",
        mLeft: "+",
        mRight: "+",
    },
};
/**
 * Render Markdown input to an ANSI string.
 */
export function render(markdown, userOptions = {}) {
    const options = resolveOptions(userOptions);
    const style = createStyler({ color: options.color });
    const tree = normalizeNodes(parse(dedent(markdown)));
    const ctx = { options, style };
    const body = renderChildren(tree.children, ctx, 0, true).join("");
    return options.color ? body : stripAnsi(body);
}
/**
 * Create a reusable renderer with fixed options.
 */
export function createRenderer(options) {
    return (md) => render(md, options);
}
function renderChildren(children, ctx, indentLevel = 0, isTightList = false) {
    const out = [];
    for (let i = 0; i < children.length; i += 1) {
        const node = children[i];
        if (!node)
            continue;
        // Heuristic: some sources emit a standalone "[lang]" line before a fenced block.
        if (node.type === "paragraph" &&
            node.children.length === 1 &&
            node.children[0]?.type === "text") {
            const langMatch = node.children[0]?.value.trim().match(/^\[([^\]]+)]$/);
            const next = children[i + 1];
            if (langMatch && next && next.type === "code" && !next.lang) {
                next.lang = langMatch[1];
                i += 1; // skip label paragraph, render the code next
                out.push(renderNode(next, ctx, indentLevel, isTightList));
                continue;
            }
        }
        out.push(renderNode(node, ctx, indentLevel, isTightList));
    }
    return out.flat();
}
function renderNode(node, ctx, indentLevel, isTightList) {
    switch (node.type) {
        case "paragraph":
            return renderParagraph(node, ctx, indentLevel);
        case "heading":
            return renderHeading(node, ctx);
        case "thematicBreak":
            return renderHr(ctx);
        case "blockquote":
            return renderBlockquote(node, ctx, indentLevel);
        case "list":
            return renderList(node, ctx, indentLevel);
        case "listItem":
            return renderListItem(node, ctx, indentLevel, isTightList);
        case "code":
            return renderCodeBlock(node, ctx);
        case "table":
            return renderTable(node, ctx);
        case "definition":
            return renderDefinition(node, ctx);
        default:
            return []; // inline handled elsewhere or intentionally skipped
    }
}
function renderParagraph(node, ctx, indentLevel) {
    const text = renderInline(node.children, ctx);
    const prefix = " ".repeat(ctx.options.listIndent * indentLevel);
    const rawLines = text.split("\n");
    const normalized = [];
    const defPattern = /^\[[^\]]+]:\s+\S/;
    let inDefinitions = false;
    for (const line of rawLines) {
        if (defPattern.test(line) &&
            normalized.length > 0 &&
            normalized.at(-1) !== "") {
            normalized.push(""); // insert blank line before footer-style definitions
        }
        if (defPattern.test(line)) {
            inDefinitions = true;
            normalized.push(line);
            continue;
        }
        if (inDefinitions && line.trim() === "") {
            // skip extra blank lines inside the definitions block
            continue;
        }
        inDefinitions = false;
        normalized.push(line);
    }
    const lines = normalized.flatMap((l) => wrapWithPrefix(l, ctx.options.width ?? 80, ctx.options.wrap, prefix));
    return lines.map((l) => `${l}\n`);
}
function renderHeading(node, ctx) {
    const text = renderInline(node.children, ctx);
    const styled = ctx.style(text, ctx.options.theme.heading);
    return [`\n${styled}\n`];
}
function renderHr(ctx) {
    const width = ctx.options.wrap
        ? Math.min(ctx.options.width ?? HR_WIDTH, HR_WIDTH)
        : HR_WIDTH;
    const line = "—".repeat(width);
    return [`${ctx.style(line, ctx.options.theme.hr)}\n`];
}
function renderBlockquote(node, ctx, indentLevel) {
    // Render blockquote children as text, then wrap with the quote prefix so
    // wrapping accounts for prefix width.
    const inner = renderChildren(node.children, ctx, indentLevel);
    const prefix = ctx.style(ctx.options.quotePrefix, ctx.options.theme.quote);
    const text = inner.join("").trimEnd();
    const wrapped = wrapWithPrefix(text, ctx.options.width ?? 80, ctx.options.wrap, prefix);
    return wrapped.map((l) => `${l}\n`);
}
function renderList(node, ctx, indentLevel) {
    const tight = node.spread === false;
    const items = node.children.flatMap((item, idx) => renderListItem(item, ctx, indentLevel, tight, Boolean(node.ordered), node.start ?? 1, idx));
    return items;
}
function renderListItem(node, ctx, indentLevel, tight, ordered = false, start = 1, idx = 0) {
    const marker = ordered ? `${start + idx}.` : "-";
    const markerStyled = ctx.style(marker, ctx.options.theme.listMarker);
    const content = renderChildren(node.children, ctx, indentLevel + 1, tight)
        .join("")
        .trimEnd()
        .split("\n");
    // Drop leading blank lines so bullets prefix real content (e.g., headings in lists)
    while (content.length && (content[0]?.trim() ?? "") === "") {
        content.shift();
    }
    const isTask = typeof node.checked === "boolean";
    const box = isTask && node.checked ? "[x]" : "[ ]";
    const firstBullet = " ".repeat(ctx.options.listIndent * indentLevel) +
        (isTask
            ? `${ctx.style(box, ctx.options.theme.listMarker)} `
            : `${markerStyled} `);
    const lines = [];
    content.forEach((line, i) => {
        const clean = line.replace(/^\s+/, "");
        const prefix = i === 0
            ? firstBullet
            : `${" ".repeat(ctx.options.listIndent * indentLevel)}${" ".repeat(ctx.options.listIndent)}`;
        lines.push(prefix + clean);
    });
    if (!tight)
        lines.push("");
    return lines.map((l) => `${l}\n`);
}
function renderDefinition(node, _ctx) {
    const title = node.title ? ` "${node.title}"` : "";
    const line = `[${node.identifier}]: ${node.url ?? ""}${title}`;
    // Insert a leading blank line to visually separate footers from body.
    return [`\n${line}\n`];
}
function renderCodeBlock(node, ctx) {
    const theme = ctx.options.theme.blockCode || ctx.options.theme.inlineCode;
    const lines = (node.value ?? "").split("\n");
    const isDiff = node.lang === "diff";
    const gutterWidth = ctx.options.codeGutter
        ? String(lines.length).length + 2
        : 0;
    const shouldWrap = isDiff ? false : ctx.options.codeWrap;
    const useBox = ctx.options.codeBox && lines.length > 1;
    const boxPadding = useBox ? 4 : 0;
    const wrapLimit = shouldWrap && ctx.options.wrap && ctx.options.width
        ? Math.max(1, ctx.options.width - boxPadding - gutterWidth)
        : undefined; // undefined => no hard wrap limit
    const contentLines = lines.flatMap((line, idx) => {
        const segments = wrapLimit !== undefined ? wrapCodeLine(line, wrapLimit) : [line];
        return segments.map((segment, segIdx) => {
            const highlighted = ctx.options.highlighter?.(segment, node.lang ?? undefined) ??
                ctx.style(segment, theme);
            if (!ctx.options.codeGutter)
                return highlighted;
            const num = segIdx === 0
                ? String(idx + 1).padStart(gutterWidth - 2, " ")
                : " ".repeat(gutterWidth - 1);
            return `${ctx.style(num, { dim: true })} ${highlighted}`;
        });
    });
    if (!useBox) {
        return [`${contentLines.join("\n")}\n\n`];
    }
    // Boxed block
    const maxLine = Math.max(...contentLines.map((l) => visibleWidth(l)), 0);
    const minInner = node.lang ? node.lang.length + 2 : 0;
    const wrapTarget = ctx.options.codeWrap && ctx.options.width
        ? Math.min(maxLine, Math.max(1, ctx.options.width - 4))
        : maxLine;
    const labelRaw = node.lang ? `[${node.lang}]` : "";
    const labelStyled = labelRaw ? ctx.style(labelRaw, { dim: true }) : "";
    const innerWidth = Math.max(ctx.options.codeWrap ? wrapTarget : maxLine, minInner, labelRaw.length);
    const topPadding = Math.max(0, innerWidth - labelRaw.length + 1);
    const topRaw = labelRaw.length > 0
        ? `┌ ${labelStyled}${"─".repeat(topPadding)}┐`
        : `┌ ${"─".repeat(innerWidth)} ┐`;
    const bottomRaw = `└${"─".repeat(innerWidth + 2)}┘`;
    const top = ctx.style(topRaw, { dim: true });
    const bottom = ctx.style(bottomRaw, { dim: true });
    const boxLines = contentLines.map((ln) => {
        const pad = Math.max(0, innerWidth - visibleWidth(ln));
        const left = ctx.style("│ ", { dim: true });
        const right = ctx.style(" │", { dim: true });
        return `${left}${ln}${" ".repeat(pad)}${right}`;
    });
    return [`${top}\n${boxLines.join("\n")}\n${bottom}\n\n`];
}
function renderInline(children, ctx) {
    let out = "";
    for (const node of children) {
        switch (node.type) {
            case "text":
                out += node.value;
                break;
            case "emphasis":
                out += ctx.style(renderInline(node.children, ctx), ctx.options.theme.emph);
                break;
            case "strong":
                out += ctx.style(renderInline(node.children, ctx), ctx.options.theme.strong);
                break;
            case "delete":
                out += ctx.style(renderInline(node.children, ctx), { strike: true });
                break;
            case "inlineCode": {
                const codeTheme = ctx.options.theme.inlineCode || ctx.options.theme.blockCode;
                const content = ctx.style(node.value, codeTheme);
                out += content;
                break;
            }
            case "link":
                out += renderLink(node, ctx);
                break;
            case "break":
                out += "\n";
                break;
            default:
                if ("value" in node && typeof node.value === "string")
                    out += node.value;
        }
    }
    return out;
}
function renderLink(node, ctx) {
    const label = renderInline(node.children, ctx) || node.url;
    const url = node.url || "";
    if (url.startsWith("mailto:")) {
        // Treat mailto autolinks as plain text to avoid unwanted styling in tables.
        return label;
    }
    if (ctx.options.hyperlinks && url) {
        return osc8(url, label);
    }
    if (url && label !== url) {
        return (ctx.style(label, ctx.options.theme.link) +
            ctx.style(` (${url})`, { dim: true }));
    }
    return ctx.style(label, ctx.options.theme.link);
}
function renderTable(node, ctx) {
    const header = node.children[0];
    if (!header)
        return [];
    const rows = node.children.slice(1);
    const cells = [header, ...rows].map((row) => row.children.map((cell) => renderInline(cell.children, ctx)));
    const colCount = Math.max(...cells.map((r) => r.length));
    const widths = new Array(colCount).fill(1);
    const aligns = node.align || [];
    const pad = ctx.options.tablePadding;
    const minContent = Math.max(1, ctx.options.tableEllipsis.length + 1);
    // ensure we always have room for at least one visible char + ellipsis + padding
    const minColWidth = Math.max(1, pad * 2 + minContent);
    cells.forEach((row) => {
        row.forEach((cell, idx) => {
            // Cap each column to MAX_COL but keep at least 1
            widths[idx] = Math.max(widths[idx], Math.min(MAX_COL, visibleWidth(cell)));
        });
    });
    const totalWidth = widths.reduce((a, b) => a + b, 0) + 3 * colCount + 1;
    if (ctx.options.wrap && ctx.options.width && totalWidth > ctx.options.width) {
        // Shrink widest columns until the table fits; allow overflow if already at minima
        let over = totalWidth - ctx.options.width;
        while (over > 0) {
            const i = widths.indexOf(Math.max(...widths));
            if (widths[i] <= minColWidth)
                break;
            widths[i] -= 1;
            over -= 1;
        }
    }
    for (let i = 0; i < widths.length; i += 1) {
        if (widths[i] < minColWidth)
            widths[i] = minColWidth;
    }
    const renderRow = (row, isHeader = false) => {
        const linesPerCol = row.map((cell, idx) => {
            const padded = ` ${cell} `;
            const target = Math.max(minContent, widths[idx] - pad * 2);
            const cellText = ctx.options.tableTruncate
                ? truncateCell(cell, target, ctx.options.tableEllipsis)
                : padded;
            const wrapped = wrapText(cellText, ctx.options.wrap ? target : Number.MAX_SAFE_INTEGER, ctx.options.wrap);
            return wrapped.map((l) => padCell(` ${l} `, widths[idx], aligns[idx] ?? "left", ctx.options.tablePadding));
        });
        // Row height = max wrapped lines in any column; pad shorter ones
        const height = Math.max(...linesPerCol.map((c) => c.length));
        const out = [];
        for (let i = 0; i < height; i += 1) {
            const parts = linesPerCol.map((col, idx) => {
                const content = col[i] ?? padCell("", widths[idx], aligns[idx] ?? "left");
                return isHeader
                    ? ctx.style(content, ctx.options.theme.tableHeader)
                    : ctx.style(content, ctx.options.theme.tableCell);
            });
            out.push(parts);
        }
        return out;
    };
    const headerRows = renderRow(header.children.map((c) => renderInline(c.children, ctx)), true);
    const bodyRows = rows.flatMap((r) => renderRow(r.children.map((c) => renderInline(c.children, ctx))));
    if (ctx.options.tableBorder === "none") {
        const lines = [...headerRows, ...bodyRows]
            .map((row) => row.join(" | "))
            .join("\n");
        return [`${lines}\n\n`];
    }
    const box = TABLE_BOX[ctx.options.tableBorder] || TABLE_BOX.unicode;
    const hLine = (sepMid, sepLeft, sepRight) => `${sepLeft}${widths
        .map((w) => box.hSep.repeat(w))
        .join(sepMid)}${sepRight}\n`;
    const top = hLine(box.tSep, box.topLeft, box.topRight);
    const mid = hLine(box.mSep, box.mLeft, box.mRight);
    const bottom = hLine(box.bSep, box.bottomLeft, box.bottomRight);
    const renderFlat = (rowsArr) => rowsArr
        .map((r) => `${box.vSep}${r.map((c) => c).join(box.vSep)}${box.vSep}\n`)
        .join("");
    const dense = ctx.options.tableDense;
    const out = [
        top,
        renderFlat(headerRows),
        dense ? "" : mid,
        renderFlat(bodyRows),
        bottom,
        "\n",
    ];
    return out;
}
function truncateCell(text, width, ellipsis) {
    if (stringWidth(text) <= width)
        return text;
    if (width <= ellipsis.length)
        return ellipsis.slice(0, width);
    return text.slice(0, width - ellipsis.length) + ellipsis;
}
function wrapCodeLine(text, width) {
    // Hard-wrap code even without spaces while keeping ANSI-safe width accounting.
    if (width <= 0)
        return [text];
    const parts = [];
    let current = "";
    for (const ch of [...text]) {
        const chWidth = stringWidth(ch);
        if (visibleWidth(current) + chWidth > width) {
            parts.push(current);
            current = ch;
            continue;
        }
        current += ch;
    }
    if (current !== "")
        parts.push(current);
    return parts.length ? parts : [""];
}
function padCell(text, width, align = "left", _padSpaces = 0) {
    const core = text;
    const pad = width - stringWidth(stripAnsi(core));
    if (pad <= 0)
        return core;
    if (align === "right")
        return `${" ".repeat(pad)}${core}`;
    if (align === "center") {
        const left = Math.floor(pad / 2);
        const right = pad - left;
        return `${" ".repeat(left)}${core}${" ".repeat(right)}`;
    }
    return `${core}${" ".repeat(pad)}`;
}
